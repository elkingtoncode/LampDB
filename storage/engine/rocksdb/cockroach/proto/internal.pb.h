// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cockroach/proto/internal.proto

#ifndef PROTOBUF_cockroach_2fproto_2finternal_2eproto__INCLUDED
#define PROTOBUF_cockroach_2fproto_2finternal_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "cockroach/proto/api.pb.h"
#include "cockroach/proto/metadata.pb.h"
#include "gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)

namespace cockroach {
namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

class ResponseCacheEntry;
class RaftCommandUnion;
class RaftCommand;
class RaftMessageRequest;
class RaftMessageResponse;
class InternalTimeSeriesData;
class InternalTimeSeriesSample;
class RaftTruncatedState;
class RaftSnapshotData;
class RaftSnapshotData_KeyValue;

enum InternalValueType {
  _CR_TS = 1
};
bool InternalValueType_IsValid(int value);
const InternalValueType InternalValueType_MIN = _CR_TS;
const InternalValueType InternalValueType_MAX = _CR_TS;
const int InternalValueType_ARRAYSIZE = InternalValueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InternalValueType_descriptor();
inline const ::std::string& InternalValueType_Name(InternalValueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InternalValueType_descriptor(), value);
}
inline bool InternalValueType_Parse(
    const ::std::string& name, InternalValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InternalValueType>(
    InternalValueType_descriptor(), name, value);
}
// ===================================================================

class ResponseCacheEntry : public ::google::protobuf::Message {
 public:
  ResponseCacheEntry();
  virtual ~ResponseCacheEntry();

  ResponseCacheEntry(const ResponseCacheEntry& from);

  inline ResponseCacheEntry& operator=(const ResponseCacheEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCacheEntry& default_instance();

  enum ValueCase {
    kPut = 1,
    kConditionalPut = 2,
    kIncrement = 3,
    kDelete = 4,
    kDeleteRange = 5,
    kEndTransaction = 6,
    kHeartbeatTxn = 7,
    kGc = 8,
    kPushTxn = 9,
    kResolveIntent = 10,
    kResolveIntentRange = 11,
    kMerge = 12,
    kTruncateLog = 13,
    kLeaderLease = 14,
    kBatch = 30,
    VALUE_NOT_SET = 0,
  };

  void Swap(ResponseCacheEntry* other);

  // implements Message ----------------------------------------------

  inline ResponseCacheEntry* New() const { return New(NULL); }

  ResponseCacheEntry* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseCacheEntry& from);
  void MergeFrom(const ResponseCacheEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseCacheEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.PutResponse put = 1;
  bool has_put() const;
  void clear_put();
  static const int kPutFieldNumber = 1;
  const ::cockroach::proto::PutResponse& put() const;
  ::cockroach::proto::PutResponse* mutable_put();
  ::cockroach::proto::PutResponse* release_put();
  void set_allocated_put(::cockroach::proto::PutResponse* put);

  // optional .cockroach.proto.ConditionalPutResponse conditional_put = 2;
  bool has_conditional_put() const;
  void clear_conditional_put();
  static const int kConditionalPutFieldNumber = 2;
  const ::cockroach::proto::ConditionalPutResponse& conditional_put() const;
  ::cockroach::proto::ConditionalPutResponse* mutable_conditional_put();
  ::cockroach::proto::ConditionalPutResponse* release_conditional_put();
  void set_allocated_conditional_put(::cockroach::proto::ConditionalPutResponse* conditional_put);

  // optional .cockroach.proto.IncrementResponse increment = 3;
  bool has_increment() const;
  void clear_increment();
  static const int kIncrementFieldNumber = 3;
  const ::cockroach::proto::IncrementResponse& increment() const;
  ::cockroach::proto::IncrementResponse* mutable_increment();
  ::cockroach::proto::IncrementResponse* release_increment();
  void set_allocated_increment(::cockroach::proto::IncrementResponse* increment);

  // optional .cockroach.proto.DeleteResponse delete = 4;
  bool has_delete_() const;
  void clear_delete_();
  static const int kDeleteFieldNumber = 4;
  const ::cockroach::proto::DeleteResponse& delete_() const;
  ::cockroach::proto::DeleteResponse* mutable_delete_();
  ::cockroach::proto::DeleteResponse* release_delete_();
  void set_allocated_delete_(::cockroach::proto::DeleteResponse* delete_);

  // optional .cockroach.proto.DeleteRangeResponse delete_range = 5;
  bool has_delete_range() const;
  void clear_delete_range();
  static const int kDeleteRangeFieldNumber = 5;
  const ::cockroach::proto::DeleteRangeResponse& delete_range() const;
  ::cockroach::proto::DeleteRangeResponse* mutable_delete_range();
  ::cockroach::proto::DeleteRangeResponse* release_delete_range();
  void set_allocated_delete_range(::cockroach::proto::DeleteRangeResponse* delete_range);

  // optional .cockroach.proto.EndTransactionResponse end_transaction = 6;
  bool has_end_transaction() const;
  void clear_end_transaction();
  static const int kEndTransactionFieldNumber = 6;
  const ::cockroach::proto::EndTransactionResponse& end_transaction() const;
  ::cockroach::proto::EndTransactionResponse* mutable_end_transaction();
  ::cockroach::proto::EndTransactionResponse* release_end_transaction();
  void set_allocated_end_transaction(::cockroach::proto::EndTransactionResponse* end_transaction);

  // optional .cockroach.proto.HeartbeatTxnResponse heartbeat_txn = 7;
  bool has_heartbeat_txn() const;
  void clear_heartbeat_txn();
  static const int kHeartbeatTxnFieldNumber = 7;
  const ::cockroach::proto::HeartbeatTxnResponse& heartbeat_txn() const;
  ::cockroach::proto::HeartbeatTxnResponse* mutable_heartbeat_txn();
  ::cockroach::proto::HeartbeatTxnResponse* release_heartbeat_txn();
  void set_allocated_heartbeat_txn(::cockroach::proto::HeartbeatTxnResponse* heartbeat_txn);

  // optional .cockroach.proto.GCResponse gc = 8;
  bool has_gc() const;
  void clear_gc();
  static const int kGcFieldNumber = 8;
  const ::cockroach::proto::GCResponse& gc() const;
  ::cockroach::proto::GCResponse* mutable_gc();
  ::cockroach::proto::GCResponse* release_gc();
  void set_allocated_gc(::cockroach::proto::GCResponse* gc);

  // optional .cockroach.proto.PushTxnResponse push_txn = 9;
  bool has_push_txn() const;
  void clear_push_txn();
  static const int kPushTxnFieldNumber = 9;
  const ::cockroach::proto::PushTxnResponse& push_txn() const;
  ::cockroach::proto::PushTxnResponse* mutable_push_txn();
  ::cockroach::proto::PushTxnResponse* release_push_txn();
  void set_allocated_push_txn(::cockroach::proto::PushTxnResponse* push_txn);

  // optional .cockroach.proto.ResolveIntentResponse resolve_intent = 10;
  bool has_resolve_intent() const;
  void clear_resolve_intent();
  static const int kResolveIntentFieldNumber = 10;
  const ::cockroach::proto::ResolveIntentResponse& resolve_intent() const;
  ::cockroach::proto::ResolveIntentResponse* mutable_resolve_intent();
  ::cockroach::proto::ResolveIntentResponse* release_resolve_intent();
  void set_allocated_resolve_intent(::cockroach::proto::ResolveIntentResponse* resolve_intent);

  // optional .cockroach.proto.ResolveIntentRangeResponse resolve_intent_range = 11;
  bool has_resolve_intent_range() const;
  void clear_resolve_intent_range();
  static const int kResolveIntentRangeFieldNumber = 11;
  const ::cockroach::proto::ResolveIntentRangeResponse& resolve_intent_range() const;
  ::cockroach::proto::ResolveIntentRangeResponse* mutable_resolve_intent_range();
  ::cockroach::proto::ResolveIntentRangeResponse* release_resolve_intent_range();
  void set_allocated_resolve_intent_range(::cockroach::proto::ResolveIntentRangeResponse* resolve_intent_range);

  // optional .cockroach.proto.MergeResponse merge = 12;
  bool has_merge() const;
  void clear_merge();
  static const int kMergeFieldNumber = 12;
  const ::cockroach::proto::MergeResponse& merge() const;
  ::cockroach::proto::MergeResponse* mutable_merge();
  ::cockroach::proto::MergeResponse* release_merge();
  void set_allocated_merge(::cockroach::proto::MergeResponse* merge);

  // optional .cockroach.proto.TruncateLogResponse truncate_log = 13;
  bool has_truncate_log() const;
  void clear_truncate_log();
  static const int kTruncateLogFieldNumber = 13;
  const ::cockroach::proto::TruncateLogResponse& truncate_log() const;
  ::cockroach::proto::TruncateLogResponse* mutable_truncate_log();
  ::cockroach::proto::TruncateLogResponse* release_truncate_log();
  void set_allocated_truncate_log(::cockroach::proto::TruncateLogResponse* truncate_log);

  // optional .cockroach.proto.LeaderLeaseResponse leader_lease = 14;
  bool has_leader_lease() const;
  void clear_leader_lease();
  static const int kLeaderLeaseFieldNumber = 14;
  const ::cockroach::proto::LeaderLeaseResponse& leader_lease() const;
  ::cockroach::proto::LeaderLeaseResponse* mutable_leader_lease();
  ::cockroach::proto::LeaderLeaseResponse* release_leader_lease();
  void set_allocated_leader_lease(::cockroach::proto::LeaderLeaseResponse* leader_lease);

  // optional .cockroach.proto.BatchResponse batch = 30;
  bool has_batch() const;
  void clear_batch();
  static const int kBatchFieldNumber = 30;
  const ::cockroach::proto::BatchResponse& batch() const;
  ::cockroach::proto::BatchResponse* mutable_batch();
  ::cockroach::proto::BatchResponse* release_batch();
  void set_allocated_batch(::cockroach::proto::BatchResponse* batch);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cockroach.proto.ResponseCacheEntry)
 private:
  inline void set_has_put();
  inline void set_has_conditional_put();
  inline void set_has_increment();
  inline void set_has_delete_();
  inline void set_has_delete_range();
  inline void set_has_end_transaction();
  inline void set_has_heartbeat_txn();
  inline void set_has_gc();
  inline void set_has_push_txn();
  inline void set_has_resolve_intent();
  inline void set_has_resolve_intent_range();
  inline void set_has_merge();
  inline void set_has_truncate_log();
  inline void set_has_leader_lease();
  inline void set_has_batch();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ValueUnion {
    ValueUnion() {}
    ::cockroach::proto::PutResponse* put_;
    ::cockroach::proto::ConditionalPutResponse* conditional_put_;
    ::cockroach::proto::IncrementResponse* increment_;
    ::cockroach::proto::DeleteResponse* delete__;
    ::cockroach::proto::DeleteRangeResponse* delete_range_;
    ::cockroach::proto::EndTransactionResponse* end_transaction_;
    ::cockroach::proto::HeartbeatTxnResponse* heartbeat_txn_;
    ::cockroach::proto::GCResponse* gc_;
    ::cockroach::proto::PushTxnResponse* push_txn_;
    ::cockroach::proto::ResolveIntentResponse* resolve_intent_;
    ::cockroach::proto::ResolveIntentRangeResponse* resolve_intent_range_;
    ::cockroach::proto::MergeResponse* merge_;
    ::cockroach::proto::TruncateLogResponse* truncate_log_;
    ::cockroach::proto::LeaderLeaseResponse* leader_lease_;
    ::cockroach::proto::BatchResponse* batch_;
  } value_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static ResponseCacheEntry* default_instance_;
};
// -------------------------------------------------------------------

class RaftCommandUnion : public ::google::protobuf::Message {
 public:
  RaftCommandUnion();
  virtual ~RaftCommandUnion();

  RaftCommandUnion(const RaftCommandUnion& from);

  inline RaftCommandUnion& operator=(const RaftCommandUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftCommandUnion& default_instance();

  enum ValueCase {
    kGet = 1,
    kPut = 2,
    kConditionalPut = 3,
    kIncrement = 4,
    kDelete = 5,
    kDeleteRange = 6,
    kScan = 7,
    kEndTransaction = 8,
    kRangeLookup = 9,
    kHeartbeatTxn = 10,
    kGc = 11,
    kPushTxn = 12,
    kResolveIntent = 13,
    kResolveIntentRange = 14,
    kMergeResponse = 15,
    kTruncateLog = 16,
    kLease = 17,
    kReverseScan = 18,
    kBatch = 30,
    VALUE_NOT_SET = 0,
  };

  void Swap(RaftCommandUnion* other);

  // implements Message ----------------------------------------------

  inline RaftCommandUnion* New() const { return New(NULL); }

  RaftCommandUnion* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftCommandUnion& from);
  void MergeFrom(const RaftCommandUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RaftCommandUnion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.GetRequest get = 1;
  bool has_get() const;
  void clear_get();
  static const int kGetFieldNumber = 1;
  const ::cockroach::proto::GetRequest& get() const;
  ::cockroach::proto::GetRequest* mutable_get();
  ::cockroach::proto::GetRequest* release_get();
  void set_allocated_get(::cockroach::proto::GetRequest* get);

  // optional .cockroach.proto.PutRequest put = 2;
  bool has_put() const;
  void clear_put();
  static const int kPutFieldNumber = 2;
  const ::cockroach::proto::PutRequest& put() const;
  ::cockroach::proto::PutRequest* mutable_put();
  ::cockroach::proto::PutRequest* release_put();
  void set_allocated_put(::cockroach::proto::PutRequest* put);

  // optional .cockroach.proto.ConditionalPutRequest conditional_put = 3;
  bool has_conditional_put() const;
  void clear_conditional_put();
  static const int kConditionalPutFieldNumber = 3;
  const ::cockroach::proto::ConditionalPutRequest& conditional_put() const;
  ::cockroach::proto::ConditionalPutRequest* mutable_conditional_put();
  ::cockroach::proto::ConditionalPutRequest* release_conditional_put();
  void set_allocated_conditional_put(::cockroach::proto::ConditionalPutRequest* conditional_put);

  // optional .cockroach.proto.IncrementRequest increment = 4;
  bool has_increment() const;
  void clear_increment();
  static const int kIncrementFieldNumber = 4;
  const ::cockroach::proto::IncrementRequest& increment() const;
  ::cockroach::proto::IncrementRequest* mutable_increment();
  ::cockroach::proto::IncrementRequest* release_increment();
  void set_allocated_increment(::cockroach::proto::IncrementRequest* increment);

  // optional .cockroach.proto.DeleteRequest delete = 5;
  bool has_delete_() const;
  void clear_delete_();
  static const int kDeleteFieldNumber = 5;
  const ::cockroach::proto::DeleteRequest& delete_() const;
  ::cockroach::proto::DeleteRequest* mutable_delete_();
  ::cockroach::proto::DeleteRequest* release_delete_();
  void set_allocated_delete_(::cockroach::proto::DeleteRequest* delete_);

  // optional .cockroach.proto.DeleteRangeRequest delete_range = 6;
  bool has_delete_range() const;
  void clear_delete_range();
  static const int kDeleteRangeFieldNumber = 6;
  const ::cockroach::proto::DeleteRangeRequest& delete_range() const;
  ::cockroach::proto::DeleteRangeRequest* mutable_delete_range();
  ::cockroach::proto::DeleteRangeRequest* release_delete_range();
  void set_allocated_delete_range(::cockroach::proto::DeleteRangeRequest* delete_range);

  // optional .cockroach.proto.ScanRequest scan = 7;
  bool has_scan() const;
  void clear_scan();
  static const int kScanFieldNumber = 7;
  const ::cockroach::proto::ScanRequest& scan() const;
  ::cockroach::proto::ScanRequest* mutable_scan();
  ::cockroach::proto::ScanRequest* release_scan();
  void set_allocated_scan(::cockroach::proto::ScanRequest* scan);

  // optional .cockroach.proto.EndTransactionRequest end_transaction = 8;
  bool has_end_transaction() const;
  void clear_end_transaction();
  static const int kEndTransactionFieldNumber = 8;
  const ::cockroach::proto::EndTransactionRequest& end_transaction() const;
  ::cockroach::proto::EndTransactionRequest* mutable_end_transaction();
  ::cockroach::proto::EndTransactionRequest* release_end_transaction();
  void set_allocated_end_transaction(::cockroach::proto::EndTransactionRequest* end_transaction);

  // optional .cockroach.proto.RangeLookupRequest range_lookup = 9;
  bool has_range_lookup() const;
  void clear_range_lookup();
  static const int kRangeLookupFieldNumber = 9;
  const ::cockroach::proto::RangeLookupRequest& range_lookup() const;
  ::cockroach::proto::RangeLookupRequest* mutable_range_lookup();
  ::cockroach::proto::RangeLookupRequest* release_range_lookup();
  void set_allocated_range_lookup(::cockroach::proto::RangeLookupRequest* range_lookup);

  // optional .cockroach.proto.HeartbeatTxnRequest heartbeat_txn = 10;
  bool has_heartbeat_txn() const;
  void clear_heartbeat_txn();
  static const int kHeartbeatTxnFieldNumber = 10;
  const ::cockroach::proto::HeartbeatTxnRequest& heartbeat_txn() const;
  ::cockroach::proto::HeartbeatTxnRequest* mutable_heartbeat_txn();
  ::cockroach::proto::HeartbeatTxnRequest* release_heartbeat_txn();
  void set_allocated_heartbeat_txn(::cockroach::proto::HeartbeatTxnRequest* heartbeat_txn);

  // optional .cockroach.proto.GCRequest gc = 11;
  bool has_gc() const;
  void clear_gc();
  static const int kGcFieldNumber = 11;
  const ::cockroach::proto::GCRequest& gc() const;
  ::cockroach::proto::GCRequest* mutable_gc();
  ::cockroach::proto::GCRequest* release_gc();
  void set_allocated_gc(::cockroach::proto::GCRequest* gc);

  // optional .cockroach.proto.PushTxnRequest push_txn = 12;
  bool has_push_txn() const;
  void clear_push_txn();
  static const int kPushTxnFieldNumber = 12;
  const ::cockroach::proto::PushTxnRequest& push_txn() const;
  ::cockroach::proto::PushTxnRequest* mutable_push_txn();
  ::cockroach::proto::PushTxnRequest* release_push_txn();
  void set_allocated_push_txn(::cockroach::proto::PushTxnRequest* push_txn);

  // optional .cockroach.proto.ResolveIntentRequest resolve_intent = 13;
  bool has_resolve_intent() const;
  void clear_resolve_intent();
  static const int kResolveIntentFieldNumber = 13;
  const ::cockroach::proto::ResolveIntentRequest& resolve_intent() const;
  ::cockroach::proto::ResolveIntentRequest* mutable_resolve_intent();
  ::cockroach::proto::ResolveIntentRequest* release_resolve_intent();
  void set_allocated_resolve_intent(::cockroach::proto::ResolveIntentRequest* resolve_intent);

  // optional .cockroach.proto.ResolveIntentRangeRequest resolve_intent_range = 14;
  bool has_resolve_intent_range() const;
  void clear_resolve_intent_range();
  static const int kResolveIntentRangeFieldNumber = 14;
  const ::cockroach::proto::ResolveIntentRangeRequest& resolve_intent_range() const;
  ::cockroach::proto::ResolveIntentRangeRequest* mutable_resolve_intent_range();
  ::cockroach::proto::ResolveIntentRangeRequest* release_resolve_intent_range();
  void set_allocated_resolve_intent_range(::cockroach::proto::ResolveIntentRangeRequest* resolve_intent_range);

  // optional .cockroach.proto.MergeRequest merge_response = 15;
  bool has_merge_response() const;
  void clear_merge_response();
  static const int kMergeResponseFieldNumber = 15;
  const ::cockroach::proto::MergeRequest& merge_response() const;
  ::cockroach::proto::MergeRequest* mutable_merge_response();
  ::cockroach::proto::MergeRequest* release_merge_response();
  void set_allocated_merge_response(::cockroach::proto::MergeRequest* merge_response);

  // optional .cockroach.proto.TruncateLogRequest truncate_log = 16;
  bool has_truncate_log() const;
  void clear_truncate_log();
  static const int kTruncateLogFieldNumber = 16;
  const ::cockroach::proto::TruncateLogRequest& truncate_log() const;
  ::cockroach::proto::TruncateLogRequest* mutable_truncate_log();
  ::cockroach::proto::TruncateLogRequest* release_truncate_log();
  void set_allocated_truncate_log(::cockroach::proto::TruncateLogRequest* truncate_log);

  // optional .cockroach.proto.LeaderLeaseRequest lease = 17;
  bool has_lease() const;
  void clear_lease();
  static const int kLeaseFieldNumber = 17;
  const ::cockroach::proto::LeaderLeaseRequest& lease() const;
  ::cockroach::proto::LeaderLeaseRequest* mutable_lease();
  ::cockroach::proto::LeaderLeaseRequest* release_lease();
  void set_allocated_lease(::cockroach::proto::LeaderLeaseRequest* lease);

  // optional .cockroach.proto.ReverseScanRequest reverse_scan = 18;
  bool has_reverse_scan() const;
  void clear_reverse_scan();
  static const int kReverseScanFieldNumber = 18;
  const ::cockroach::proto::ReverseScanRequest& reverse_scan() const;
  ::cockroach::proto::ReverseScanRequest* mutable_reverse_scan();
  ::cockroach::proto::ReverseScanRequest* release_reverse_scan();
  void set_allocated_reverse_scan(::cockroach::proto::ReverseScanRequest* reverse_scan);

  // optional .cockroach.proto.BatchRequest batch = 30;
  bool has_batch() const;
  void clear_batch();
  static const int kBatchFieldNumber = 30;
  const ::cockroach::proto::BatchRequest& batch() const;
  ::cockroach::proto::BatchRequest* mutable_batch();
  ::cockroach::proto::BatchRequest* release_batch();
  void set_allocated_batch(::cockroach::proto::BatchRequest* batch);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cockroach.proto.RaftCommandUnion)
 private:
  inline void set_has_get();
  inline void set_has_put();
  inline void set_has_conditional_put();
  inline void set_has_increment();
  inline void set_has_delete_();
  inline void set_has_delete_range();
  inline void set_has_scan();
  inline void set_has_end_transaction();
  inline void set_has_range_lookup();
  inline void set_has_heartbeat_txn();
  inline void set_has_gc();
  inline void set_has_push_txn();
  inline void set_has_resolve_intent();
  inline void set_has_resolve_intent_range();
  inline void set_has_merge_response();
  inline void set_has_truncate_log();
  inline void set_has_lease();
  inline void set_has_reverse_scan();
  inline void set_has_batch();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ValueUnion {
    ValueUnion() {}
    ::cockroach::proto::GetRequest* get_;
    ::cockroach::proto::PutRequest* put_;
    ::cockroach::proto::ConditionalPutRequest* conditional_put_;
    ::cockroach::proto::IncrementRequest* increment_;
    ::cockroach::proto::DeleteRequest* delete__;
    ::cockroach::proto::DeleteRangeRequest* delete_range_;
    ::cockroach::proto::ScanRequest* scan_;
    ::cockroach::proto::EndTransactionRequest* end_transaction_;
    ::cockroach::proto::RangeLookupRequest* range_lookup_;
    ::cockroach::proto::HeartbeatTxnRequest* heartbeat_txn_;
    ::cockroach::proto::GCRequest* gc_;
    ::cockroach::proto::PushTxnRequest* push_txn_;
    ::cockroach::proto::ResolveIntentRequest* resolve_intent_;
    ::cockroach::proto::ResolveIntentRangeRequest* resolve_intent_range_;
    ::cockroach::proto::MergeRequest* merge_response_;
    ::cockroach::proto::TruncateLogRequest* truncate_log_;
    ::cockroach::proto::LeaderLeaseRequest* lease_;
    ::cockroach::proto::ReverseScanRequest* reverse_scan_;
    ::cockroach::proto::BatchRequest* batch_;
  } value_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static RaftCommandUnion* default_instance_;
};
// -------------------------------------------------------------------

class RaftCommand : public ::google::protobuf::Message {
 public:
  RaftCommand();
  virtual ~RaftCommand();

  RaftCommand(const RaftCommand& from);

  inline RaftCommand& operator=(const RaftCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftCommand& default_instance();

  void Swap(RaftCommand* other);

  // implements Message ----------------------------------------------

  inline RaftCommand* New() const { return New(NULL); }

  RaftCommand* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftCommand& from);
  void MergeFrom(const RaftCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RaftCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 range_id = 1;
  bool has_range_id() const;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 1;
  ::google::protobuf::int64 range_id() const;
  void set_range_id(::google::protobuf::int64 value);

  // optional uint64 origin_node_id = 2;
  bool has_origin_node_id() const;
  void clear_origin_node_id();
  static const int kOriginNodeIdFieldNumber = 2;
  ::google::protobuf::uint64 origin_node_id() const;
  void set_origin_node_id(::google::protobuf::uint64 value);

  // optional .cockroach.proto.RaftCommandUnion cmd = 3;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 3;
  const ::cockroach::proto::RaftCommandUnion& cmd() const;
  ::cockroach::proto::RaftCommandUnion* mutable_cmd();
  ::cockroach::proto::RaftCommandUnion* release_cmd();
  void set_allocated_cmd(::cockroach::proto::RaftCommandUnion* cmd);

  // @@protoc_insertion_point(class_scope:cockroach.proto.RaftCommand)
 private:
  inline void set_has_range_id();
  inline void clear_has_range_id();
  inline void set_has_origin_node_id();
  inline void clear_has_origin_node_id();
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 range_id_;
  ::google::protobuf::uint64 origin_node_id_;
  ::cockroach::proto::RaftCommandUnion* cmd_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static RaftCommand* default_instance_;
};
// -------------------------------------------------------------------

class RaftMessageRequest : public ::google::protobuf::Message {
 public:
  RaftMessageRequest();
  virtual ~RaftMessageRequest();

  RaftMessageRequest(const RaftMessageRequest& from);

  inline RaftMessageRequest& operator=(const RaftMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftMessageRequest& default_instance();

  void Swap(RaftMessageRequest* other);

  // implements Message ----------------------------------------------

  inline RaftMessageRequest* New() const { return New(NULL); }

  RaftMessageRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftMessageRequest& from);
  void MergeFrom(const RaftMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RaftMessageRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 group_id = 1;
  bool has_group_id() const;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  ::google::protobuf::uint64 group_id() const;
  void set_group_id(::google::protobuf::uint64 value);

  // optional bytes msg = 2;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  void set_msg(const char* value);
  void set_msg(const void* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:cockroach.proto.RaftMessageRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 group_id_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static RaftMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class RaftMessageResponse : public ::google::protobuf::Message {
 public:
  RaftMessageResponse();
  virtual ~RaftMessageResponse();

  RaftMessageResponse(const RaftMessageResponse& from);

  inline RaftMessageResponse& operator=(const RaftMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftMessageResponse& default_instance();

  void Swap(RaftMessageResponse* other);

  // implements Message ----------------------------------------------

  inline RaftMessageResponse* New() const { return New(NULL); }

  RaftMessageResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftMessageResponse& from);
  void MergeFrom(const RaftMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RaftMessageResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cockroach.proto.RaftMessageResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static RaftMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalTimeSeriesData : public ::google::protobuf::Message {
 public:
  InternalTimeSeriesData();
  virtual ~InternalTimeSeriesData();

  InternalTimeSeriesData(const InternalTimeSeriesData& from);

  inline InternalTimeSeriesData& operator=(const InternalTimeSeriesData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalTimeSeriesData& default_instance();

  void Swap(InternalTimeSeriesData* other);

  // implements Message ----------------------------------------------

  inline InternalTimeSeriesData* New() const { return New(NULL); }

  InternalTimeSeriesData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalTimeSeriesData& from);
  void MergeFrom(const InternalTimeSeriesData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InternalTimeSeriesData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 start_timestamp_nanos = 1;
  bool has_start_timestamp_nanos() const;
  void clear_start_timestamp_nanos();
  static const int kStartTimestampNanosFieldNumber = 1;
  ::google::protobuf::int64 start_timestamp_nanos() const;
  void set_start_timestamp_nanos(::google::protobuf::int64 value);

  // optional int64 sample_duration_nanos = 2;
  bool has_sample_duration_nanos() const;
  void clear_sample_duration_nanos();
  static const int kSampleDurationNanosFieldNumber = 2;
  ::google::protobuf::int64 sample_duration_nanos() const;
  void set_sample_duration_nanos(::google::protobuf::int64 value);

  // repeated .cockroach.proto.InternalTimeSeriesSample samples = 3;
  int samples_size() const;
  void clear_samples();
  static const int kSamplesFieldNumber = 3;
  const ::cockroach::proto::InternalTimeSeriesSample& samples(int index) const;
  ::cockroach::proto::InternalTimeSeriesSample* mutable_samples(int index);
  ::cockroach::proto::InternalTimeSeriesSample* add_samples();
  const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalTimeSeriesSample >&
      samples() const;
  ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalTimeSeriesSample >*
      mutable_samples();

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalTimeSeriesData)
 private:
  inline void set_has_start_timestamp_nanos();
  inline void clear_has_start_timestamp_nanos();
  inline void set_has_sample_duration_nanos();
  inline void clear_has_sample_duration_nanos();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 start_timestamp_nanos_;
  ::google::protobuf::int64 sample_duration_nanos_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalTimeSeriesSample > samples_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalTimeSeriesData* default_instance_;
};
// -------------------------------------------------------------------

class InternalTimeSeriesSample : public ::google::protobuf::Message {
 public:
  InternalTimeSeriesSample();
  virtual ~InternalTimeSeriesSample();

  InternalTimeSeriesSample(const InternalTimeSeriesSample& from);

  inline InternalTimeSeriesSample& operator=(const InternalTimeSeriesSample& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalTimeSeriesSample& default_instance();

  void Swap(InternalTimeSeriesSample* other);

  // implements Message ----------------------------------------------

  inline InternalTimeSeriesSample* New() const { return New(NULL); }

  InternalTimeSeriesSample* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalTimeSeriesSample& from);
  void MergeFrom(const InternalTimeSeriesSample& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InternalTimeSeriesSample* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 offset = 1;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::int32 offset() const;
  void set_offset(::google::protobuf::int32 value);

  // optional uint32 count = 6;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 6;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // optional double sum = 7;
  bool has_sum() const;
  void clear_sum();
  static const int kSumFieldNumber = 7;
  double sum() const;
  void set_sum(double value);

  // optional double max = 8;
  bool has_max() const;
  void clear_max();
  static const int kMaxFieldNumber = 8;
  double max() const;
  void set_max(double value);

  // optional double min = 9;
  bool has_min() const;
  void clear_min();
  static const int kMinFieldNumber = 9;
  double min() const;
  void set_min(double value);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalTimeSeriesSample)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_sum();
  inline void clear_has_sum();
  inline void set_has_max();
  inline void clear_has_max();
  inline void set_has_min();
  inline void clear_has_min();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::uint32 count_;
  double sum_;
  double max_;
  double min_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalTimeSeriesSample* default_instance_;
};
// -------------------------------------------------------------------

class RaftTruncatedState : public ::google::protobuf::Message {
 public:
  RaftTruncatedState();
  virtual ~RaftTruncatedState();

  RaftTruncatedState(const RaftTruncatedState& from);

  inline RaftTruncatedState& operator=(const RaftTruncatedState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftTruncatedState& default_instance();

  void Swap(RaftTruncatedState* other);

  // implements Message ----------------------------------------------

  inline RaftTruncatedState* New() const { return New(NULL); }

  RaftTruncatedState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftTruncatedState& from);
  void MergeFrom(const RaftTruncatedState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RaftTruncatedState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint64 index() const;
  void set_index(::google::protobuf::uint64 value);

  // optional uint64 term = 2;
  bool has_term() const;
  void clear_term();
  static const int kTermFieldNumber = 2;
  ::google::protobuf::uint64 term() const;
  void set_term(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cockroach.proto.RaftTruncatedState)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_term();
  inline void clear_has_term();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 index_;
  ::google::protobuf::uint64 term_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static RaftTruncatedState* default_instance_;
};
// -------------------------------------------------------------------

class RaftSnapshotData_KeyValue : public ::google::protobuf::Message {
 public:
  RaftSnapshotData_KeyValue();
  virtual ~RaftSnapshotData_KeyValue();

  RaftSnapshotData_KeyValue(const RaftSnapshotData_KeyValue& from);

  inline RaftSnapshotData_KeyValue& operator=(const RaftSnapshotData_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftSnapshotData_KeyValue& default_instance();

  void Swap(RaftSnapshotData_KeyValue* other);

  // implements Message ----------------------------------------------

  inline RaftSnapshotData_KeyValue* New() const { return New(NULL); }

  RaftSnapshotData_KeyValue* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftSnapshotData_KeyValue& from);
  void MergeFrom(const RaftSnapshotData_KeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RaftSnapshotData_KeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional bytes value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:cockroach.proto.RaftSnapshotData.KeyValue)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static RaftSnapshotData_KeyValue* default_instance_;
};
// -------------------------------------------------------------------

class RaftSnapshotData : public ::google::protobuf::Message {
 public:
  RaftSnapshotData();
  virtual ~RaftSnapshotData();

  RaftSnapshotData(const RaftSnapshotData& from);

  inline RaftSnapshotData& operator=(const RaftSnapshotData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftSnapshotData& default_instance();

  void Swap(RaftSnapshotData* other);

  // implements Message ----------------------------------------------

  inline RaftSnapshotData* New() const { return New(NULL); }

  RaftSnapshotData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftSnapshotData& from);
  void MergeFrom(const RaftSnapshotData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RaftSnapshotData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RaftSnapshotData_KeyValue KeyValue;

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.RangeDescriptor range_descriptor = 1;
  bool has_range_descriptor() const;
  void clear_range_descriptor();
  static const int kRangeDescriptorFieldNumber = 1;
  const ::cockroach::proto::RangeDescriptor& range_descriptor() const;
  ::cockroach::proto::RangeDescriptor* mutable_range_descriptor();
  ::cockroach::proto::RangeDescriptor* release_range_descriptor();
  void set_allocated_range_descriptor(::cockroach::proto::RangeDescriptor* range_descriptor);

  // repeated .cockroach.proto.RaftSnapshotData.KeyValue KV = 2;
  int kv_size() const;
  void clear_kv();
  static const int kKVFieldNumber = 2;
  const ::cockroach::proto::RaftSnapshotData_KeyValue& kv(int index) const;
  ::cockroach::proto::RaftSnapshotData_KeyValue* mutable_kv(int index);
  ::cockroach::proto::RaftSnapshotData_KeyValue* add_kv();
  const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RaftSnapshotData_KeyValue >&
      kv() const;
  ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RaftSnapshotData_KeyValue >*
      mutable_kv();

  // @@protoc_insertion_point(class_scope:cockroach.proto.RaftSnapshotData)
 private:
  inline void set_has_range_descriptor();
  inline void clear_has_range_descriptor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::RangeDescriptor* range_descriptor_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RaftSnapshotData_KeyValue > kv_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static RaftSnapshotData* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ResponseCacheEntry

// optional .cockroach.proto.PutResponse put = 1;
inline bool ResponseCacheEntry::has_put() const {
  return value_case() == kPut;
}
inline void ResponseCacheEntry::set_has_put() {
  _oneof_case_[0] = kPut;
}
inline void ResponseCacheEntry::clear_put() {
  if (has_put()) {
    delete value_.put_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::PutResponse& ResponseCacheEntry::put() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.put)
  return has_put() ? *value_.put_
                      : ::cockroach::proto::PutResponse::default_instance();
}
inline ::cockroach::proto::PutResponse* ResponseCacheEntry::mutable_put() {
  if (!has_put()) {
    clear_value();
    set_has_put();
    value_.put_ = new ::cockroach::proto::PutResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.put)
  return value_.put_;
}
inline ::cockroach::proto::PutResponse* ResponseCacheEntry::release_put() {
  if (has_put()) {
    clear_has_value();
    ::cockroach::proto::PutResponse* temp = value_.put_;
    value_.put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_put(::cockroach::proto::PutResponse* put) {
  clear_value();
  if (put) {
    set_has_put();
    value_.put_ = put;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.put)
}

// optional .cockroach.proto.ConditionalPutResponse conditional_put = 2;
inline bool ResponseCacheEntry::has_conditional_put() const {
  return value_case() == kConditionalPut;
}
inline void ResponseCacheEntry::set_has_conditional_put() {
  _oneof_case_[0] = kConditionalPut;
}
inline void ResponseCacheEntry::clear_conditional_put() {
  if (has_conditional_put()) {
    delete value_.conditional_put_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ConditionalPutResponse& ResponseCacheEntry::conditional_put() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.conditional_put)
  return has_conditional_put() ? *value_.conditional_put_
                      : ::cockroach::proto::ConditionalPutResponse::default_instance();
}
inline ::cockroach::proto::ConditionalPutResponse* ResponseCacheEntry::mutable_conditional_put() {
  if (!has_conditional_put()) {
    clear_value();
    set_has_conditional_put();
    value_.conditional_put_ = new ::cockroach::proto::ConditionalPutResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.conditional_put)
  return value_.conditional_put_;
}
inline ::cockroach::proto::ConditionalPutResponse* ResponseCacheEntry::release_conditional_put() {
  if (has_conditional_put()) {
    clear_has_value();
    ::cockroach::proto::ConditionalPutResponse* temp = value_.conditional_put_;
    value_.conditional_put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_conditional_put(::cockroach::proto::ConditionalPutResponse* conditional_put) {
  clear_value();
  if (conditional_put) {
    set_has_conditional_put();
    value_.conditional_put_ = conditional_put;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.conditional_put)
}

// optional .cockroach.proto.IncrementResponse increment = 3;
inline bool ResponseCacheEntry::has_increment() const {
  return value_case() == kIncrement;
}
inline void ResponseCacheEntry::set_has_increment() {
  _oneof_case_[0] = kIncrement;
}
inline void ResponseCacheEntry::clear_increment() {
  if (has_increment()) {
    delete value_.increment_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::IncrementResponse& ResponseCacheEntry::increment() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.increment)
  return has_increment() ? *value_.increment_
                      : ::cockroach::proto::IncrementResponse::default_instance();
}
inline ::cockroach::proto::IncrementResponse* ResponseCacheEntry::mutable_increment() {
  if (!has_increment()) {
    clear_value();
    set_has_increment();
    value_.increment_ = new ::cockroach::proto::IncrementResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.increment)
  return value_.increment_;
}
inline ::cockroach::proto::IncrementResponse* ResponseCacheEntry::release_increment() {
  if (has_increment()) {
    clear_has_value();
    ::cockroach::proto::IncrementResponse* temp = value_.increment_;
    value_.increment_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_increment(::cockroach::proto::IncrementResponse* increment) {
  clear_value();
  if (increment) {
    set_has_increment();
    value_.increment_ = increment;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.increment)
}

// optional .cockroach.proto.DeleteResponse delete = 4;
inline bool ResponseCacheEntry::has_delete_() const {
  return value_case() == kDelete;
}
inline void ResponseCacheEntry::set_has_delete_() {
  _oneof_case_[0] = kDelete;
}
inline void ResponseCacheEntry::clear_delete_() {
  if (has_delete_()) {
    delete value_.delete__;
    clear_has_value();
  }
}
inline const ::cockroach::proto::DeleteResponse& ResponseCacheEntry::delete_() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.delete)
  return has_delete_() ? *value_.delete__
                      : ::cockroach::proto::DeleteResponse::default_instance();
}
inline ::cockroach::proto::DeleteResponse* ResponseCacheEntry::mutable_delete_() {
  if (!has_delete_()) {
    clear_value();
    set_has_delete_();
    value_.delete__ = new ::cockroach::proto::DeleteResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.delete)
  return value_.delete__;
}
inline ::cockroach::proto::DeleteResponse* ResponseCacheEntry::release_delete_() {
  if (has_delete_()) {
    clear_has_value();
    ::cockroach::proto::DeleteResponse* temp = value_.delete__;
    value_.delete__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_delete_(::cockroach::proto::DeleteResponse* delete_) {
  clear_value();
  if (delete_) {
    set_has_delete_();
    value_.delete__ = delete_;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.delete)
}

// optional .cockroach.proto.DeleteRangeResponse delete_range = 5;
inline bool ResponseCacheEntry::has_delete_range() const {
  return value_case() == kDeleteRange;
}
inline void ResponseCacheEntry::set_has_delete_range() {
  _oneof_case_[0] = kDeleteRange;
}
inline void ResponseCacheEntry::clear_delete_range() {
  if (has_delete_range()) {
    delete value_.delete_range_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::DeleteRangeResponse& ResponseCacheEntry::delete_range() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.delete_range)
  return has_delete_range() ? *value_.delete_range_
                      : ::cockroach::proto::DeleteRangeResponse::default_instance();
}
inline ::cockroach::proto::DeleteRangeResponse* ResponseCacheEntry::mutable_delete_range() {
  if (!has_delete_range()) {
    clear_value();
    set_has_delete_range();
    value_.delete_range_ = new ::cockroach::proto::DeleteRangeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.delete_range)
  return value_.delete_range_;
}
inline ::cockroach::proto::DeleteRangeResponse* ResponseCacheEntry::release_delete_range() {
  if (has_delete_range()) {
    clear_has_value();
    ::cockroach::proto::DeleteRangeResponse* temp = value_.delete_range_;
    value_.delete_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_delete_range(::cockroach::proto::DeleteRangeResponse* delete_range) {
  clear_value();
  if (delete_range) {
    set_has_delete_range();
    value_.delete_range_ = delete_range;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.delete_range)
}

// optional .cockroach.proto.EndTransactionResponse end_transaction = 6;
inline bool ResponseCacheEntry::has_end_transaction() const {
  return value_case() == kEndTransaction;
}
inline void ResponseCacheEntry::set_has_end_transaction() {
  _oneof_case_[0] = kEndTransaction;
}
inline void ResponseCacheEntry::clear_end_transaction() {
  if (has_end_transaction()) {
    delete value_.end_transaction_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::EndTransactionResponse& ResponseCacheEntry::end_transaction() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.end_transaction)
  return has_end_transaction() ? *value_.end_transaction_
                      : ::cockroach::proto::EndTransactionResponse::default_instance();
}
inline ::cockroach::proto::EndTransactionResponse* ResponseCacheEntry::mutable_end_transaction() {
  if (!has_end_transaction()) {
    clear_value();
    set_has_end_transaction();
    value_.end_transaction_ = new ::cockroach::proto::EndTransactionResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.end_transaction)
  return value_.end_transaction_;
}
inline ::cockroach::proto::EndTransactionResponse* ResponseCacheEntry::release_end_transaction() {
  if (has_end_transaction()) {
    clear_has_value();
    ::cockroach::proto::EndTransactionResponse* temp = value_.end_transaction_;
    value_.end_transaction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_end_transaction(::cockroach::proto::EndTransactionResponse* end_transaction) {
  clear_value();
  if (end_transaction) {
    set_has_end_transaction();
    value_.end_transaction_ = end_transaction;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.end_transaction)
}

// optional .cockroach.proto.HeartbeatTxnResponse heartbeat_txn = 7;
inline bool ResponseCacheEntry::has_heartbeat_txn() const {
  return value_case() == kHeartbeatTxn;
}
inline void ResponseCacheEntry::set_has_heartbeat_txn() {
  _oneof_case_[0] = kHeartbeatTxn;
}
inline void ResponseCacheEntry::clear_heartbeat_txn() {
  if (has_heartbeat_txn()) {
    delete value_.heartbeat_txn_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::HeartbeatTxnResponse& ResponseCacheEntry::heartbeat_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.heartbeat_txn)
  return has_heartbeat_txn() ? *value_.heartbeat_txn_
                      : ::cockroach::proto::HeartbeatTxnResponse::default_instance();
}
inline ::cockroach::proto::HeartbeatTxnResponse* ResponseCacheEntry::mutable_heartbeat_txn() {
  if (!has_heartbeat_txn()) {
    clear_value();
    set_has_heartbeat_txn();
    value_.heartbeat_txn_ = new ::cockroach::proto::HeartbeatTxnResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.heartbeat_txn)
  return value_.heartbeat_txn_;
}
inline ::cockroach::proto::HeartbeatTxnResponse* ResponseCacheEntry::release_heartbeat_txn() {
  if (has_heartbeat_txn()) {
    clear_has_value();
    ::cockroach::proto::HeartbeatTxnResponse* temp = value_.heartbeat_txn_;
    value_.heartbeat_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_heartbeat_txn(::cockroach::proto::HeartbeatTxnResponse* heartbeat_txn) {
  clear_value();
  if (heartbeat_txn) {
    set_has_heartbeat_txn();
    value_.heartbeat_txn_ = heartbeat_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.heartbeat_txn)
}

// optional .cockroach.proto.GCResponse gc = 8;
inline bool ResponseCacheEntry::has_gc() const {
  return value_case() == kGc;
}
inline void ResponseCacheEntry::set_has_gc() {
  _oneof_case_[0] = kGc;
}
inline void ResponseCacheEntry::clear_gc() {
  if (has_gc()) {
    delete value_.gc_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::GCResponse& ResponseCacheEntry::gc() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.gc)
  return has_gc() ? *value_.gc_
                      : ::cockroach::proto::GCResponse::default_instance();
}
inline ::cockroach::proto::GCResponse* ResponseCacheEntry::mutable_gc() {
  if (!has_gc()) {
    clear_value();
    set_has_gc();
    value_.gc_ = new ::cockroach::proto::GCResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.gc)
  return value_.gc_;
}
inline ::cockroach::proto::GCResponse* ResponseCacheEntry::release_gc() {
  if (has_gc()) {
    clear_has_value();
    ::cockroach::proto::GCResponse* temp = value_.gc_;
    value_.gc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_gc(::cockroach::proto::GCResponse* gc) {
  clear_value();
  if (gc) {
    set_has_gc();
    value_.gc_ = gc;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.gc)
}

// optional .cockroach.proto.PushTxnResponse push_txn = 9;
inline bool ResponseCacheEntry::has_push_txn() const {
  return value_case() == kPushTxn;
}
inline void ResponseCacheEntry::set_has_push_txn() {
  _oneof_case_[0] = kPushTxn;
}
inline void ResponseCacheEntry::clear_push_txn() {
  if (has_push_txn()) {
    delete value_.push_txn_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::PushTxnResponse& ResponseCacheEntry::push_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.push_txn)
  return has_push_txn() ? *value_.push_txn_
                      : ::cockroach::proto::PushTxnResponse::default_instance();
}
inline ::cockroach::proto::PushTxnResponse* ResponseCacheEntry::mutable_push_txn() {
  if (!has_push_txn()) {
    clear_value();
    set_has_push_txn();
    value_.push_txn_ = new ::cockroach::proto::PushTxnResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.push_txn)
  return value_.push_txn_;
}
inline ::cockroach::proto::PushTxnResponse* ResponseCacheEntry::release_push_txn() {
  if (has_push_txn()) {
    clear_has_value();
    ::cockroach::proto::PushTxnResponse* temp = value_.push_txn_;
    value_.push_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_push_txn(::cockroach::proto::PushTxnResponse* push_txn) {
  clear_value();
  if (push_txn) {
    set_has_push_txn();
    value_.push_txn_ = push_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.push_txn)
}

// optional .cockroach.proto.ResolveIntentResponse resolve_intent = 10;
inline bool ResponseCacheEntry::has_resolve_intent() const {
  return value_case() == kResolveIntent;
}
inline void ResponseCacheEntry::set_has_resolve_intent() {
  _oneof_case_[0] = kResolveIntent;
}
inline void ResponseCacheEntry::clear_resolve_intent() {
  if (has_resolve_intent()) {
    delete value_.resolve_intent_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ResolveIntentResponse& ResponseCacheEntry::resolve_intent() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.resolve_intent)
  return has_resolve_intent() ? *value_.resolve_intent_
                      : ::cockroach::proto::ResolveIntentResponse::default_instance();
}
inline ::cockroach::proto::ResolveIntentResponse* ResponseCacheEntry::mutable_resolve_intent() {
  if (!has_resolve_intent()) {
    clear_value();
    set_has_resolve_intent();
    value_.resolve_intent_ = new ::cockroach::proto::ResolveIntentResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.resolve_intent)
  return value_.resolve_intent_;
}
inline ::cockroach::proto::ResolveIntentResponse* ResponseCacheEntry::release_resolve_intent() {
  if (has_resolve_intent()) {
    clear_has_value();
    ::cockroach::proto::ResolveIntentResponse* temp = value_.resolve_intent_;
    value_.resolve_intent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_resolve_intent(::cockroach::proto::ResolveIntentResponse* resolve_intent) {
  clear_value();
  if (resolve_intent) {
    set_has_resolve_intent();
    value_.resolve_intent_ = resolve_intent;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.resolve_intent)
}

// optional .cockroach.proto.ResolveIntentRangeResponse resolve_intent_range = 11;
inline bool ResponseCacheEntry::has_resolve_intent_range() const {
  return value_case() == kResolveIntentRange;
}
inline void ResponseCacheEntry::set_has_resolve_intent_range() {
  _oneof_case_[0] = kResolveIntentRange;
}
inline void ResponseCacheEntry::clear_resolve_intent_range() {
  if (has_resolve_intent_range()) {
    delete value_.resolve_intent_range_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ResolveIntentRangeResponse& ResponseCacheEntry::resolve_intent_range() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.resolve_intent_range)
  return has_resolve_intent_range() ? *value_.resolve_intent_range_
                      : ::cockroach::proto::ResolveIntentRangeResponse::default_instance();
}
inline ::cockroach::proto::ResolveIntentRangeResponse* ResponseCacheEntry::mutable_resolve_intent_range() {
  if (!has_resolve_intent_range()) {
    clear_value();
    set_has_resolve_intent_range();
    value_.resolve_intent_range_ = new ::cockroach::proto::ResolveIntentRangeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.resolve_intent_range)
  return value_.resolve_intent_range_;
}
inline ::cockroach::proto::ResolveIntentRangeResponse* ResponseCacheEntry::release_resolve_intent_range() {
  if (has_resolve_intent_range()) {
    clear_has_value();
    ::cockroach::proto::ResolveIntentRangeResponse* temp = value_.resolve_intent_range_;
    value_.resolve_intent_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_resolve_intent_range(::cockroach::proto::ResolveIntentRangeResponse* resolve_intent_range) {
  clear_value();
  if (resolve_intent_range) {
    set_has_resolve_intent_range();
    value_.resolve_intent_range_ = resolve_intent_range;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.resolve_intent_range)
}

// optional .cockroach.proto.MergeResponse merge = 12;
inline bool ResponseCacheEntry::has_merge() const {
  return value_case() == kMerge;
}
inline void ResponseCacheEntry::set_has_merge() {
  _oneof_case_[0] = kMerge;
}
inline void ResponseCacheEntry::clear_merge() {
  if (has_merge()) {
    delete value_.merge_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::MergeResponse& ResponseCacheEntry::merge() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.merge)
  return has_merge() ? *value_.merge_
                      : ::cockroach::proto::MergeResponse::default_instance();
}
inline ::cockroach::proto::MergeResponse* ResponseCacheEntry::mutable_merge() {
  if (!has_merge()) {
    clear_value();
    set_has_merge();
    value_.merge_ = new ::cockroach::proto::MergeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.merge)
  return value_.merge_;
}
inline ::cockroach::proto::MergeResponse* ResponseCacheEntry::release_merge() {
  if (has_merge()) {
    clear_has_value();
    ::cockroach::proto::MergeResponse* temp = value_.merge_;
    value_.merge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_merge(::cockroach::proto::MergeResponse* merge) {
  clear_value();
  if (merge) {
    set_has_merge();
    value_.merge_ = merge;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.merge)
}

// optional .cockroach.proto.TruncateLogResponse truncate_log = 13;
inline bool ResponseCacheEntry::has_truncate_log() const {
  return value_case() == kTruncateLog;
}
inline void ResponseCacheEntry::set_has_truncate_log() {
  _oneof_case_[0] = kTruncateLog;
}
inline void ResponseCacheEntry::clear_truncate_log() {
  if (has_truncate_log()) {
    delete value_.truncate_log_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::TruncateLogResponse& ResponseCacheEntry::truncate_log() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.truncate_log)
  return has_truncate_log() ? *value_.truncate_log_
                      : ::cockroach::proto::TruncateLogResponse::default_instance();
}
inline ::cockroach::proto::TruncateLogResponse* ResponseCacheEntry::mutable_truncate_log() {
  if (!has_truncate_log()) {
    clear_value();
    set_has_truncate_log();
    value_.truncate_log_ = new ::cockroach::proto::TruncateLogResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.truncate_log)
  return value_.truncate_log_;
}
inline ::cockroach::proto::TruncateLogResponse* ResponseCacheEntry::release_truncate_log() {
  if (has_truncate_log()) {
    clear_has_value();
    ::cockroach::proto::TruncateLogResponse* temp = value_.truncate_log_;
    value_.truncate_log_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_truncate_log(::cockroach::proto::TruncateLogResponse* truncate_log) {
  clear_value();
  if (truncate_log) {
    set_has_truncate_log();
    value_.truncate_log_ = truncate_log;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.truncate_log)
}

// optional .cockroach.proto.LeaderLeaseResponse leader_lease = 14;
inline bool ResponseCacheEntry::has_leader_lease() const {
  return value_case() == kLeaderLease;
}
inline void ResponseCacheEntry::set_has_leader_lease() {
  _oneof_case_[0] = kLeaderLease;
}
inline void ResponseCacheEntry::clear_leader_lease() {
  if (has_leader_lease()) {
    delete value_.leader_lease_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::LeaderLeaseResponse& ResponseCacheEntry::leader_lease() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.leader_lease)
  return has_leader_lease() ? *value_.leader_lease_
                      : ::cockroach::proto::LeaderLeaseResponse::default_instance();
}
inline ::cockroach::proto::LeaderLeaseResponse* ResponseCacheEntry::mutable_leader_lease() {
  if (!has_leader_lease()) {
    clear_value();
    set_has_leader_lease();
    value_.leader_lease_ = new ::cockroach::proto::LeaderLeaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.leader_lease)
  return value_.leader_lease_;
}
inline ::cockroach::proto::LeaderLeaseResponse* ResponseCacheEntry::release_leader_lease() {
  if (has_leader_lease()) {
    clear_has_value();
    ::cockroach::proto::LeaderLeaseResponse* temp = value_.leader_lease_;
    value_.leader_lease_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_leader_lease(::cockroach::proto::LeaderLeaseResponse* leader_lease) {
  clear_value();
  if (leader_lease) {
    set_has_leader_lease();
    value_.leader_lease_ = leader_lease;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.leader_lease)
}

// optional .cockroach.proto.BatchResponse batch = 30;
inline bool ResponseCacheEntry::has_batch() const {
  return value_case() == kBatch;
}
inline void ResponseCacheEntry::set_has_batch() {
  _oneof_case_[0] = kBatch;
}
inline void ResponseCacheEntry::clear_batch() {
  if (has_batch()) {
    delete value_.batch_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::BatchResponse& ResponseCacheEntry::batch() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseCacheEntry.batch)
  return has_batch() ? *value_.batch_
                      : ::cockroach::proto::BatchResponse::default_instance();
}
inline ::cockroach::proto::BatchResponse* ResponseCacheEntry::mutable_batch() {
  if (!has_batch()) {
    clear_value();
    set_has_batch();
    value_.batch_ = new ::cockroach::proto::BatchResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseCacheEntry.batch)
  return value_.batch_;
}
inline ::cockroach::proto::BatchResponse* ResponseCacheEntry::release_batch() {
  if (has_batch()) {
    clear_has_value();
    ::cockroach::proto::BatchResponse* temp = value_.batch_;
    value_.batch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ResponseCacheEntry::set_allocated_batch(::cockroach::proto::BatchResponse* batch) {
  clear_value();
  if (batch) {
    set_has_batch();
    value_.batch_ = batch;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseCacheEntry.batch)
}

inline bool ResponseCacheEntry::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void ResponseCacheEntry::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline ResponseCacheEntry::ValueCase ResponseCacheEntry::value_case() const {
  return ResponseCacheEntry::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RaftCommandUnion

// optional .cockroach.proto.GetRequest get = 1;
inline bool RaftCommandUnion::has_get() const {
  return value_case() == kGet;
}
inline void RaftCommandUnion::set_has_get() {
  _oneof_case_[0] = kGet;
}
inline void RaftCommandUnion::clear_get() {
  if (has_get()) {
    delete value_.get_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::GetRequest& RaftCommandUnion::get() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.get)
  return has_get() ? *value_.get_
                      : ::cockroach::proto::GetRequest::default_instance();
}
inline ::cockroach::proto::GetRequest* RaftCommandUnion::mutable_get() {
  if (!has_get()) {
    clear_value();
    set_has_get();
    value_.get_ = new ::cockroach::proto::GetRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.get)
  return value_.get_;
}
inline ::cockroach::proto::GetRequest* RaftCommandUnion::release_get() {
  if (has_get()) {
    clear_has_value();
    ::cockroach::proto::GetRequest* temp = value_.get_;
    value_.get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_get(::cockroach::proto::GetRequest* get) {
  clear_value();
  if (get) {
    set_has_get();
    value_.get_ = get;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.get)
}

// optional .cockroach.proto.PutRequest put = 2;
inline bool RaftCommandUnion::has_put() const {
  return value_case() == kPut;
}
inline void RaftCommandUnion::set_has_put() {
  _oneof_case_[0] = kPut;
}
inline void RaftCommandUnion::clear_put() {
  if (has_put()) {
    delete value_.put_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::PutRequest& RaftCommandUnion::put() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.put)
  return has_put() ? *value_.put_
                      : ::cockroach::proto::PutRequest::default_instance();
}
inline ::cockroach::proto::PutRequest* RaftCommandUnion::mutable_put() {
  if (!has_put()) {
    clear_value();
    set_has_put();
    value_.put_ = new ::cockroach::proto::PutRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.put)
  return value_.put_;
}
inline ::cockroach::proto::PutRequest* RaftCommandUnion::release_put() {
  if (has_put()) {
    clear_has_value();
    ::cockroach::proto::PutRequest* temp = value_.put_;
    value_.put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_put(::cockroach::proto::PutRequest* put) {
  clear_value();
  if (put) {
    set_has_put();
    value_.put_ = put;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.put)
}

// optional .cockroach.proto.ConditionalPutRequest conditional_put = 3;
inline bool RaftCommandUnion::has_conditional_put() const {
  return value_case() == kConditionalPut;
}
inline void RaftCommandUnion::set_has_conditional_put() {
  _oneof_case_[0] = kConditionalPut;
}
inline void RaftCommandUnion::clear_conditional_put() {
  if (has_conditional_put()) {
    delete value_.conditional_put_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ConditionalPutRequest& RaftCommandUnion::conditional_put() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.conditional_put)
  return has_conditional_put() ? *value_.conditional_put_
                      : ::cockroach::proto::ConditionalPutRequest::default_instance();
}
inline ::cockroach::proto::ConditionalPutRequest* RaftCommandUnion::mutable_conditional_put() {
  if (!has_conditional_put()) {
    clear_value();
    set_has_conditional_put();
    value_.conditional_put_ = new ::cockroach::proto::ConditionalPutRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.conditional_put)
  return value_.conditional_put_;
}
inline ::cockroach::proto::ConditionalPutRequest* RaftCommandUnion::release_conditional_put() {
  if (has_conditional_put()) {
    clear_has_value();
    ::cockroach::proto::ConditionalPutRequest* temp = value_.conditional_put_;
    value_.conditional_put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_conditional_put(::cockroach::proto::ConditionalPutRequest* conditional_put) {
  clear_value();
  if (conditional_put) {
    set_has_conditional_put();
    value_.conditional_put_ = conditional_put;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.conditional_put)
}

// optional .cockroach.proto.IncrementRequest increment = 4;
inline bool RaftCommandUnion::has_increment() const {
  return value_case() == kIncrement;
}
inline void RaftCommandUnion::set_has_increment() {
  _oneof_case_[0] = kIncrement;
}
inline void RaftCommandUnion::clear_increment() {
  if (has_increment()) {
    delete value_.increment_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::IncrementRequest& RaftCommandUnion::increment() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.increment)
  return has_increment() ? *value_.increment_
                      : ::cockroach::proto::IncrementRequest::default_instance();
}
inline ::cockroach::proto::IncrementRequest* RaftCommandUnion::mutable_increment() {
  if (!has_increment()) {
    clear_value();
    set_has_increment();
    value_.increment_ = new ::cockroach::proto::IncrementRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.increment)
  return value_.increment_;
}
inline ::cockroach::proto::IncrementRequest* RaftCommandUnion::release_increment() {
  if (has_increment()) {
    clear_has_value();
    ::cockroach::proto::IncrementRequest* temp = value_.increment_;
    value_.increment_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_increment(::cockroach::proto::IncrementRequest* increment) {
  clear_value();
  if (increment) {
    set_has_increment();
    value_.increment_ = increment;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.increment)
}

// optional .cockroach.proto.DeleteRequest delete = 5;
inline bool RaftCommandUnion::has_delete_() const {
  return value_case() == kDelete;
}
inline void RaftCommandUnion::set_has_delete_() {
  _oneof_case_[0] = kDelete;
}
inline void RaftCommandUnion::clear_delete_() {
  if (has_delete_()) {
    delete value_.delete__;
    clear_has_value();
  }
}
inline const ::cockroach::proto::DeleteRequest& RaftCommandUnion::delete_() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.delete)
  return has_delete_() ? *value_.delete__
                      : ::cockroach::proto::DeleteRequest::default_instance();
}
inline ::cockroach::proto::DeleteRequest* RaftCommandUnion::mutable_delete_() {
  if (!has_delete_()) {
    clear_value();
    set_has_delete_();
    value_.delete__ = new ::cockroach::proto::DeleteRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.delete)
  return value_.delete__;
}
inline ::cockroach::proto::DeleteRequest* RaftCommandUnion::release_delete_() {
  if (has_delete_()) {
    clear_has_value();
    ::cockroach::proto::DeleteRequest* temp = value_.delete__;
    value_.delete__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_delete_(::cockroach::proto::DeleteRequest* delete_) {
  clear_value();
  if (delete_) {
    set_has_delete_();
    value_.delete__ = delete_;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.delete)
}

// optional .cockroach.proto.DeleteRangeRequest delete_range = 6;
inline bool RaftCommandUnion::has_delete_range() const {
  return value_case() == kDeleteRange;
}
inline void RaftCommandUnion::set_has_delete_range() {
  _oneof_case_[0] = kDeleteRange;
}
inline void RaftCommandUnion::clear_delete_range() {
  if (has_delete_range()) {
    delete value_.delete_range_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::DeleteRangeRequest& RaftCommandUnion::delete_range() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.delete_range)
  return has_delete_range() ? *value_.delete_range_
                      : ::cockroach::proto::DeleteRangeRequest::default_instance();
}
inline ::cockroach::proto::DeleteRangeRequest* RaftCommandUnion::mutable_delete_range() {
  if (!has_delete_range()) {
    clear_value();
    set_has_delete_range();
    value_.delete_range_ = new ::cockroach::proto::DeleteRangeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.delete_range)
  return value_.delete_range_;
}
inline ::cockroach::proto::DeleteRangeRequest* RaftCommandUnion::release_delete_range() {
  if (has_delete_range()) {
    clear_has_value();
    ::cockroach::proto::DeleteRangeRequest* temp = value_.delete_range_;
    value_.delete_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_delete_range(::cockroach::proto::DeleteRangeRequest* delete_range) {
  clear_value();
  if (delete_range) {
    set_has_delete_range();
    value_.delete_range_ = delete_range;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.delete_range)
}

// optional .cockroach.proto.ScanRequest scan = 7;
inline bool RaftCommandUnion::has_scan() const {
  return value_case() == kScan;
}
inline void RaftCommandUnion::set_has_scan() {
  _oneof_case_[0] = kScan;
}
inline void RaftCommandUnion::clear_scan() {
  if (has_scan()) {
    delete value_.scan_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ScanRequest& RaftCommandUnion::scan() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.scan)
  return has_scan() ? *value_.scan_
                      : ::cockroach::proto::ScanRequest::default_instance();
}
inline ::cockroach::proto::ScanRequest* RaftCommandUnion::mutable_scan() {
  if (!has_scan()) {
    clear_value();
    set_has_scan();
    value_.scan_ = new ::cockroach::proto::ScanRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.scan)
  return value_.scan_;
}
inline ::cockroach::proto::ScanRequest* RaftCommandUnion::release_scan() {
  if (has_scan()) {
    clear_has_value();
    ::cockroach::proto::ScanRequest* temp = value_.scan_;
    value_.scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_scan(::cockroach::proto::ScanRequest* scan) {
  clear_value();
  if (scan) {
    set_has_scan();
    value_.scan_ = scan;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.scan)
}

// optional .cockroach.proto.EndTransactionRequest end_transaction = 8;
inline bool RaftCommandUnion::has_end_transaction() const {
  return value_case() == kEndTransaction;
}
inline void RaftCommandUnion::set_has_end_transaction() {
  _oneof_case_[0] = kEndTransaction;
}
inline void RaftCommandUnion::clear_end_transaction() {
  if (has_end_transaction()) {
    delete value_.end_transaction_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::EndTransactionRequest& RaftCommandUnion::end_transaction() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.end_transaction)
  return has_end_transaction() ? *value_.end_transaction_
                      : ::cockroach::proto::EndTransactionRequest::default_instance();
}
inline ::cockroach::proto::EndTransactionRequest* RaftCommandUnion::mutable_end_transaction() {
  if (!has_end_transaction()) {
    clear_value();
    set_has_end_transaction();
    value_.end_transaction_ = new ::cockroach::proto::EndTransactionRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.end_transaction)
  return value_.end_transaction_;
}
inline ::cockroach::proto::EndTransactionRequest* RaftCommandUnion::release_end_transaction() {
  if (has_end_transaction()) {
    clear_has_value();
    ::cockroach::proto::EndTransactionRequest* temp = value_.end_transaction_;
    value_.end_transaction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_end_transaction(::cockroach::proto::EndTransactionRequest* end_transaction) {
  clear_value();
  if (end_transaction) {
    set_has_end_transaction();
    value_.end_transaction_ = end_transaction;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.end_transaction)
}

// optional .cockroach.proto.RangeLookupRequest range_lookup = 9;
inline bool RaftCommandUnion::has_range_lookup() const {
  return value_case() == kRangeLookup;
}
inline void RaftCommandUnion::set_has_range_lookup() {
  _oneof_case_[0] = kRangeLookup;
}
inline void RaftCommandUnion::clear_range_lookup() {
  if (has_range_lookup()) {
    delete value_.range_lookup_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::RangeLookupRequest& RaftCommandUnion::range_lookup() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.range_lookup)
  return has_range_lookup() ? *value_.range_lookup_
                      : ::cockroach::proto::RangeLookupRequest::default_instance();
}
inline ::cockroach::proto::RangeLookupRequest* RaftCommandUnion::mutable_range_lookup() {
  if (!has_range_lookup()) {
    clear_value();
    set_has_range_lookup();
    value_.range_lookup_ = new ::cockroach::proto::RangeLookupRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.range_lookup)
  return value_.range_lookup_;
}
inline ::cockroach::proto::RangeLookupRequest* RaftCommandUnion::release_range_lookup() {
  if (has_range_lookup()) {
    clear_has_value();
    ::cockroach::proto::RangeLookupRequest* temp = value_.range_lookup_;
    value_.range_lookup_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_range_lookup(::cockroach::proto::RangeLookupRequest* range_lookup) {
  clear_value();
  if (range_lookup) {
    set_has_range_lookup();
    value_.range_lookup_ = range_lookup;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.range_lookup)
}

// optional .cockroach.proto.HeartbeatTxnRequest heartbeat_txn = 10;
inline bool RaftCommandUnion::has_heartbeat_txn() const {
  return value_case() == kHeartbeatTxn;
}
inline void RaftCommandUnion::set_has_heartbeat_txn() {
  _oneof_case_[0] = kHeartbeatTxn;
}
inline void RaftCommandUnion::clear_heartbeat_txn() {
  if (has_heartbeat_txn()) {
    delete value_.heartbeat_txn_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::HeartbeatTxnRequest& RaftCommandUnion::heartbeat_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.heartbeat_txn)
  return has_heartbeat_txn() ? *value_.heartbeat_txn_
                      : ::cockroach::proto::HeartbeatTxnRequest::default_instance();
}
inline ::cockroach::proto::HeartbeatTxnRequest* RaftCommandUnion::mutable_heartbeat_txn() {
  if (!has_heartbeat_txn()) {
    clear_value();
    set_has_heartbeat_txn();
    value_.heartbeat_txn_ = new ::cockroach::proto::HeartbeatTxnRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.heartbeat_txn)
  return value_.heartbeat_txn_;
}
inline ::cockroach::proto::HeartbeatTxnRequest* RaftCommandUnion::release_heartbeat_txn() {
  if (has_heartbeat_txn()) {
    clear_has_value();
    ::cockroach::proto::HeartbeatTxnRequest* temp = value_.heartbeat_txn_;
    value_.heartbeat_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_heartbeat_txn(::cockroach::proto::HeartbeatTxnRequest* heartbeat_txn) {
  clear_value();
  if (heartbeat_txn) {
    set_has_heartbeat_txn();
    value_.heartbeat_txn_ = heartbeat_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.heartbeat_txn)
}

// optional .cockroach.proto.GCRequest gc = 11;
inline bool RaftCommandUnion::has_gc() const {
  return value_case() == kGc;
}
inline void RaftCommandUnion::set_has_gc() {
  _oneof_case_[0] = kGc;
}
inline void RaftCommandUnion::clear_gc() {
  if (has_gc()) {
    delete value_.gc_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::GCRequest& RaftCommandUnion::gc() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.gc)
  return has_gc() ? *value_.gc_
                      : ::cockroach::proto::GCRequest::default_instance();
}
inline ::cockroach::proto::GCRequest* RaftCommandUnion::mutable_gc() {
  if (!has_gc()) {
    clear_value();
    set_has_gc();
    value_.gc_ = new ::cockroach::proto::GCRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.gc)
  return value_.gc_;
}
inline ::cockroach::proto::GCRequest* RaftCommandUnion::release_gc() {
  if (has_gc()) {
    clear_has_value();
    ::cockroach::proto::GCRequest* temp = value_.gc_;
    value_.gc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_gc(::cockroach::proto::GCRequest* gc) {
  clear_value();
  if (gc) {
    set_has_gc();
    value_.gc_ = gc;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.gc)
}

// optional .cockroach.proto.PushTxnRequest push_txn = 12;
inline bool RaftCommandUnion::has_push_txn() const {
  return value_case() == kPushTxn;
}
inline void RaftCommandUnion::set_has_push_txn() {
  _oneof_case_[0] = kPushTxn;
}
inline void RaftCommandUnion::clear_push_txn() {
  if (has_push_txn()) {
    delete value_.push_txn_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::PushTxnRequest& RaftCommandUnion::push_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.push_txn)
  return has_push_txn() ? *value_.push_txn_
                      : ::cockroach::proto::PushTxnRequest::default_instance();
}
inline ::cockroach::proto::PushTxnRequest* RaftCommandUnion::mutable_push_txn() {
  if (!has_push_txn()) {
    clear_value();
    set_has_push_txn();
    value_.push_txn_ = new ::cockroach::proto::PushTxnRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.push_txn)
  return value_.push_txn_;
}
inline ::cockroach::proto::PushTxnRequest* RaftCommandUnion::release_push_txn() {
  if (has_push_txn()) {
    clear_has_value();
    ::cockroach::proto::PushTxnRequest* temp = value_.push_txn_;
    value_.push_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_push_txn(::cockroach::proto::PushTxnRequest* push_txn) {
  clear_value();
  if (push_txn) {
    set_has_push_txn();
    value_.push_txn_ = push_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.push_txn)
}

// optional .cockroach.proto.ResolveIntentRequest resolve_intent = 13;
inline bool RaftCommandUnion::has_resolve_intent() const {
  return value_case() == kResolveIntent;
}
inline void RaftCommandUnion::set_has_resolve_intent() {
  _oneof_case_[0] = kResolveIntent;
}
inline void RaftCommandUnion::clear_resolve_intent() {
  if (has_resolve_intent()) {
    delete value_.resolve_intent_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ResolveIntentRequest& RaftCommandUnion::resolve_intent() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.resolve_intent)
  return has_resolve_intent() ? *value_.resolve_intent_
                      : ::cockroach::proto::ResolveIntentRequest::default_instance();
}
inline ::cockroach::proto::ResolveIntentRequest* RaftCommandUnion::mutable_resolve_intent() {
  if (!has_resolve_intent()) {
    clear_value();
    set_has_resolve_intent();
    value_.resolve_intent_ = new ::cockroach::proto::ResolveIntentRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.resolve_intent)
  return value_.resolve_intent_;
}
inline ::cockroach::proto::ResolveIntentRequest* RaftCommandUnion::release_resolve_intent() {
  if (has_resolve_intent()) {
    clear_has_value();
    ::cockroach::proto::ResolveIntentRequest* temp = value_.resolve_intent_;
    value_.resolve_intent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_resolve_intent(::cockroach::proto::ResolveIntentRequest* resolve_intent) {
  clear_value();
  if (resolve_intent) {
    set_has_resolve_intent();
    value_.resolve_intent_ = resolve_intent;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.resolve_intent)
}

// optional .cockroach.proto.ResolveIntentRangeRequest resolve_intent_range = 14;
inline bool RaftCommandUnion::has_resolve_intent_range() const {
  return value_case() == kResolveIntentRange;
}
inline void RaftCommandUnion::set_has_resolve_intent_range() {
  _oneof_case_[0] = kResolveIntentRange;
}
inline void RaftCommandUnion::clear_resolve_intent_range() {
  if (has_resolve_intent_range()) {
    delete value_.resolve_intent_range_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ResolveIntentRangeRequest& RaftCommandUnion::resolve_intent_range() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.resolve_intent_range)
  return has_resolve_intent_range() ? *value_.resolve_intent_range_
                      : ::cockroach::proto::ResolveIntentRangeRequest::default_instance();
}
inline ::cockroach::proto::ResolveIntentRangeRequest* RaftCommandUnion::mutable_resolve_intent_range() {
  if (!has_resolve_intent_range()) {
    clear_value();
    set_has_resolve_intent_range();
    value_.resolve_intent_range_ = new ::cockroach::proto::ResolveIntentRangeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.resolve_intent_range)
  return value_.resolve_intent_range_;
}
inline ::cockroach::proto::ResolveIntentRangeRequest* RaftCommandUnion::release_resolve_intent_range() {
  if (has_resolve_intent_range()) {
    clear_has_value();
    ::cockroach::proto::ResolveIntentRangeRequest* temp = value_.resolve_intent_range_;
    value_.resolve_intent_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_resolve_intent_range(::cockroach::proto::ResolveIntentRangeRequest* resolve_intent_range) {
  clear_value();
  if (resolve_intent_range) {
    set_has_resolve_intent_range();
    value_.resolve_intent_range_ = resolve_intent_range;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.resolve_intent_range)
}

// optional .cockroach.proto.MergeRequest merge_response = 15;
inline bool RaftCommandUnion::has_merge_response() const {
  return value_case() == kMergeResponse;
}
inline void RaftCommandUnion::set_has_merge_response() {
  _oneof_case_[0] = kMergeResponse;
}
inline void RaftCommandUnion::clear_merge_response() {
  if (has_merge_response()) {
    delete value_.merge_response_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::MergeRequest& RaftCommandUnion::merge_response() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.merge_response)
  return has_merge_response() ? *value_.merge_response_
                      : ::cockroach::proto::MergeRequest::default_instance();
}
inline ::cockroach::proto::MergeRequest* RaftCommandUnion::mutable_merge_response() {
  if (!has_merge_response()) {
    clear_value();
    set_has_merge_response();
    value_.merge_response_ = new ::cockroach::proto::MergeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.merge_response)
  return value_.merge_response_;
}
inline ::cockroach::proto::MergeRequest* RaftCommandUnion::release_merge_response() {
  if (has_merge_response()) {
    clear_has_value();
    ::cockroach::proto::MergeRequest* temp = value_.merge_response_;
    value_.merge_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_merge_response(::cockroach::proto::MergeRequest* merge_response) {
  clear_value();
  if (merge_response) {
    set_has_merge_response();
    value_.merge_response_ = merge_response;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.merge_response)
}

// optional .cockroach.proto.TruncateLogRequest truncate_log = 16;
inline bool RaftCommandUnion::has_truncate_log() const {
  return value_case() == kTruncateLog;
}
inline void RaftCommandUnion::set_has_truncate_log() {
  _oneof_case_[0] = kTruncateLog;
}
inline void RaftCommandUnion::clear_truncate_log() {
  if (has_truncate_log()) {
    delete value_.truncate_log_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::TruncateLogRequest& RaftCommandUnion::truncate_log() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.truncate_log)
  return has_truncate_log() ? *value_.truncate_log_
                      : ::cockroach::proto::TruncateLogRequest::default_instance();
}
inline ::cockroach::proto::TruncateLogRequest* RaftCommandUnion::mutable_truncate_log() {
  if (!has_truncate_log()) {
    clear_value();
    set_has_truncate_log();
    value_.truncate_log_ = new ::cockroach::proto::TruncateLogRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.truncate_log)
  return value_.truncate_log_;
}
inline ::cockroach::proto::TruncateLogRequest* RaftCommandUnion::release_truncate_log() {
  if (has_truncate_log()) {
    clear_has_value();
    ::cockroach::proto::TruncateLogRequest* temp = value_.truncate_log_;
    value_.truncate_log_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_truncate_log(::cockroach::proto::TruncateLogRequest* truncate_log) {
  clear_value();
  if (truncate_log) {
    set_has_truncate_log();
    value_.truncate_log_ = truncate_log;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.truncate_log)
}

// optional .cockroach.proto.LeaderLeaseRequest lease = 17;
inline bool RaftCommandUnion::has_lease() const {
  return value_case() == kLease;
}
inline void RaftCommandUnion::set_has_lease() {
  _oneof_case_[0] = kLease;
}
inline void RaftCommandUnion::clear_lease() {
  if (has_lease()) {
    delete value_.lease_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::LeaderLeaseRequest& RaftCommandUnion::lease() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.lease)
  return has_lease() ? *value_.lease_
                      : ::cockroach::proto::LeaderLeaseRequest::default_instance();
}
inline ::cockroach::proto::LeaderLeaseRequest* RaftCommandUnion::mutable_lease() {
  if (!has_lease()) {
    clear_value();
    set_has_lease();
    value_.lease_ = new ::cockroach::proto::LeaderLeaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.lease)
  return value_.lease_;
}
inline ::cockroach::proto::LeaderLeaseRequest* RaftCommandUnion::release_lease() {
  if (has_lease()) {
    clear_has_value();
    ::cockroach::proto::LeaderLeaseRequest* temp = value_.lease_;
    value_.lease_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_lease(::cockroach::proto::LeaderLeaseRequest* lease) {
  clear_value();
  if (lease) {
    set_has_lease();
    value_.lease_ = lease;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.lease)
}

// optional .cockroach.proto.ReverseScanRequest reverse_scan = 18;
inline bool RaftCommandUnion::has_reverse_scan() const {
  return value_case() == kReverseScan;
}
inline void RaftCommandUnion::set_has_reverse_scan() {
  _oneof_case_[0] = kReverseScan;
}
inline void RaftCommandUnion::clear_reverse_scan() {
  if (has_reverse_scan()) {
    delete value_.reverse_scan_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ReverseScanRequest& RaftCommandUnion::reverse_scan() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.reverse_scan)
  return has_reverse_scan() ? *value_.reverse_scan_
                      : ::cockroach::proto::ReverseScanRequest::default_instance();
}
inline ::cockroach::proto::ReverseScanRequest* RaftCommandUnion::mutable_reverse_scan() {
  if (!has_reverse_scan()) {
    clear_value();
    set_has_reverse_scan();
    value_.reverse_scan_ = new ::cockroach::proto::ReverseScanRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.reverse_scan)
  return value_.reverse_scan_;
}
inline ::cockroach::proto::ReverseScanRequest* RaftCommandUnion::release_reverse_scan() {
  if (has_reverse_scan()) {
    clear_has_value();
    ::cockroach::proto::ReverseScanRequest* temp = value_.reverse_scan_;
    value_.reverse_scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_reverse_scan(::cockroach::proto::ReverseScanRequest* reverse_scan) {
  clear_value();
  if (reverse_scan) {
    set_has_reverse_scan();
    value_.reverse_scan_ = reverse_scan;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.reverse_scan)
}

// optional .cockroach.proto.BatchRequest batch = 30;
inline bool RaftCommandUnion::has_batch() const {
  return value_case() == kBatch;
}
inline void RaftCommandUnion::set_has_batch() {
  _oneof_case_[0] = kBatch;
}
inline void RaftCommandUnion::clear_batch() {
  if (has_batch()) {
    delete value_.batch_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::BatchRequest& RaftCommandUnion::batch() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommandUnion.batch)
  return has_batch() ? *value_.batch_
                      : ::cockroach::proto::BatchRequest::default_instance();
}
inline ::cockroach::proto::BatchRequest* RaftCommandUnion::mutable_batch() {
  if (!has_batch()) {
    clear_value();
    set_has_batch();
    value_.batch_ = new ::cockroach::proto::BatchRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommandUnion.batch)
  return value_.batch_;
}
inline ::cockroach::proto::BatchRequest* RaftCommandUnion::release_batch() {
  if (has_batch()) {
    clear_has_value();
    ::cockroach::proto::BatchRequest* temp = value_.batch_;
    value_.batch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RaftCommandUnion::set_allocated_batch(::cockroach::proto::BatchRequest* batch) {
  clear_value();
  if (batch) {
    set_has_batch();
    value_.batch_ = batch;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommandUnion.batch)
}

inline bool RaftCommandUnion::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void RaftCommandUnion::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline RaftCommandUnion::ValueCase RaftCommandUnion::value_case() const {
  return RaftCommandUnion::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RaftCommand

// optional int64 range_id = 1;
inline bool RaftCommand::has_range_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaftCommand::set_has_range_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RaftCommand::clear_has_range_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RaftCommand::clear_range_id() {
  range_id_ = GOOGLE_LONGLONG(0);
  clear_has_range_id();
}
inline ::google::protobuf::int64 RaftCommand::range_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommand.range_id)
  return range_id_;
}
inline void RaftCommand::set_range_id(::google::protobuf::int64 value) {
  set_has_range_id();
  range_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RaftCommand.range_id)
}

// optional uint64 origin_node_id = 2;
inline bool RaftCommand::has_origin_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RaftCommand::set_has_origin_node_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RaftCommand::clear_has_origin_node_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RaftCommand::clear_origin_node_id() {
  origin_node_id_ = GOOGLE_ULONGLONG(0);
  clear_has_origin_node_id();
}
inline ::google::protobuf::uint64 RaftCommand::origin_node_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommand.origin_node_id)
  return origin_node_id_;
}
inline void RaftCommand::set_origin_node_id(::google::protobuf::uint64 value) {
  set_has_origin_node_id();
  origin_node_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RaftCommand.origin_node_id)
}

// optional .cockroach.proto.RaftCommandUnion cmd = 3;
inline bool RaftCommand::has_cmd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RaftCommand::set_has_cmd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RaftCommand::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RaftCommand::clear_cmd() {
  if (cmd_ != NULL) cmd_->::cockroach::proto::RaftCommandUnion::Clear();
  clear_has_cmd();
}
inline const ::cockroach::proto::RaftCommandUnion& RaftCommand::cmd() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftCommand.cmd)
  return cmd_ != NULL ? *cmd_ : *default_instance_->cmd_;
}
inline ::cockroach::proto::RaftCommandUnion* RaftCommand::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == NULL) {
    cmd_ = new ::cockroach::proto::RaftCommandUnion;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftCommand.cmd)
  return cmd_;
}
inline ::cockroach::proto::RaftCommandUnion* RaftCommand::release_cmd() {
  clear_has_cmd();
  ::cockroach::proto::RaftCommandUnion* temp = cmd_;
  cmd_ = NULL;
  return temp;
}
inline void RaftCommand::set_allocated_cmd(::cockroach::proto::RaftCommandUnion* cmd) {
  delete cmd_;
  cmd_ = cmd;
  if (cmd) {
    set_has_cmd();
  } else {
    clear_has_cmd();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftCommand.cmd)
}

// -------------------------------------------------------------------

// RaftMessageRequest

// optional uint64 group_id = 1;
inline bool RaftMessageRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaftMessageRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RaftMessageRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RaftMessageRequest::clear_group_id() {
  group_id_ = GOOGLE_ULONGLONG(0);
  clear_has_group_id();
}
inline ::google::protobuf::uint64 RaftMessageRequest::group_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftMessageRequest.group_id)
  return group_id_;
}
inline void RaftMessageRequest::set_group_id(::google::protobuf::uint64 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RaftMessageRequest.group_id)
}

// optional bytes msg = 2;
inline bool RaftMessageRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RaftMessageRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RaftMessageRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RaftMessageRequest::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg();
}
inline const ::std::string& RaftMessageRequest::msg() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftMessageRequest.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RaftMessageRequest::set_msg(const ::std::string& value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.RaftMessageRequest.msg)
}
inline void RaftMessageRequest::set_msg(const char* value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.RaftMessageRequest.msg)
}
inline void RaftMessageRequest::set_msg(const void* value, size_t size) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.RaftMessageRequest.msg)
}
inline ::std::string* RaftMessageRequest::mutable_msg() {
  set_has_msg();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftMessageRequest.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RaftMessageRequest::release_msg() {
  clear_has_msg();
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RaftMessageRequest::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftMessageRequest.msg)
}

// -------------------------------------------------------------------

// RaftMessageResponse

// -------------------------------------------------------------------

// InternalTimeSeriesData

// optional int64 start_timestamp_nanos = 1;
inline bool InternalTimeSeriesData::has_start_timestamp_nanos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalTimeSeriesData::set_has_start_timestamp_nanos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalTimeSeriesData::clear_has_start_timestamp_nanos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalTimeSeriesData::clear_start_timestamp_nanos() {
  start_timestamp_nanos_ = GOOGLE_LONGLONG(0);
  clear_has_start_timestamp_nanos();
}
inline ::google::protobuf::int64 InternalTimeSeriesData::start_timestamp_nanos() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesData.start_timestamp_nanos)
  return start_timestamp_nanos_;
}
inline void InternalTimeSeriesData::set_start_timestamp_nanos(::google::protobuf::int64 value) {
  set_has_start_timestamp_nanos();
  start_timestamp_nanos_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTimeSeriesData.start_timestamp_nanos)
}

// optional int64 sample_duration_nanos = 2;
inline bool InternalTimeSeriesData::has_sample_duration_nanos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalTimeSeriesData::set_has_sample_duration_nanos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalTimeSeriesData::clear_has_sample_duration_nanos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalTimeSeriesData::clear_sample_duration_nanos() {
  sample_duration_nanos_ = GOOGLE_LONGLONG(0);
  clear_has_sample_duration_nanos();
}
inline ::google::protobuf::int64 InternalTimeSeriesData::sample_duration_nanos() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesData.sample_duration_nanos)
  return sample_duration_nanos_;
}
inline void InternalTimeSeriesData::set_sample_duration_nanos(::google::protobuf::int64 value) {
  set_has_sample_duration_nanos();
  sample_duration_nanos_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTimeSeriesData.sample_duration_nanos)
}

// repeated .cockroach.proto.InternalTimeSeriesSample samples = 3;
inline int InternalTimeSeriesData::samples_size() const {
  return samples_.size();
}
inline void InternalTimeSeriesData::clear_samples() {
  samples_.Clear();
}
inline const ::cockroach::proto::InternalTimeSeriesSample& InternalTimeSeriesData::samples(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesData.samples)
  return samples_.Get(index);
}
inline ::cockroach::proto::InternalTimeSeriesSample* InternalTimeSeriesData::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalTimeSeriesData.samples)
  return samples_.Mutable(index);
}
inline ::cockroach::proto::InternalTimeSeriesSample* InternalTimeSeriesData::add_samples() {
  // @@protoc_insertion_point(field_add:cockroach.proto.InternalTimeSeriesData.samples)
  return samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalTimeSeriesSample >&
InternalTimeSeriesData::samples() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.InternalTimeSeriesData.samples)
  return samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalTimeSeriesSample >*
InternalTimeSeriesData::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.InternalTimeSeriesData.samples)
  return &samples_;
}

// -------------------------------------------------------------------

// InternalTimeSeriesSample

// optional int32 offset = 1;
inline bool InternalTimeSeriesSample::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalTimeSeriesSample::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalTimeSeriesSample::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalTimeSeriesSample::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 InternalTimeSeriesSample::offset() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesSample.offset)
  return offset_;
}
inline void InternalTimeSeriesSample::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTimeSeriesSample.offset)
}

// optional uint32 count = 6;
inline bool InternalTimeSeriesSample::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalTimeSeriesSample::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalTimeSeriesSample::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalTimeSeriesSample::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 InternalTimeSeriesSample::count() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesSample.count)
  return count_;
}
inline void InternalTimeSeriesSample::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTimeSeriesSample.count)
}

// optional double sum = 7;
inline bool InternalTimeSeriesSample::has_sum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalTimeSeriesSample::set_has_sum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalTimeSeriesSample::clear_has_sum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalTimeSeriesSample::clear_sum() {
  sum_ = 0;
  clear_has_sum();
}
inline double InternalTimeSeriesSample::sum() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesSample.sum)
  return sum_;
}
inline void InternalTimeSeriesSample::set_sum(double value) {
  set_has_sum();
  sum_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTimeSeriesSample.sum)
}

// optional double max = 8;
inline bool InternalTimeSeriesSample::has_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InternalTimeSeriesSample::set_has_max() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InternalTimeSeriesSample::clear_has_max() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InternalTimeSeriesSample::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline double InternalTimeSeriesSample::max() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesSample.max)
  return max_;
}
inline void InternalTimeSeriesSample::set_max(double value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTimeSeriesSample.max)
}

// optional double min = 9;
inline bool InternalTimeSeriesSample::has_min() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InternalTimeSeriesSample::set_has_min() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InternalTimeSeriesSample::clear_has_min() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InternalTimeSeriesSample::clear_min() {
  min_ = 0;
  clear_has_min();
}
inline double InternalTimeSeriesSample::min() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesSample.min)
  return min_;
}
inline void InternalTimeSeriesSample::set_min(double value) {
  set_has_min();
  min_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTimeSeriesSample.min)
}

// -------------------------------------------------------------------

// RaftTruncatedState

// optional uint64 index = 1;
inline bool RaftTruncatedState::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaftTruncatedState::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RaftTruncatedState::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RaftTruncatedState::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::uint64 RaftTruncatedState::index() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftTruncatedState.index)
  return index_;
}
inline void RaftTruncatedState::set_index(::google::protobuf::uint64 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RaftTruncatedState.index)
}

// optional uint64 term = 2;
inline bool RaftTruncatedState::has_term() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RaftTruncatedState::set_has_term() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RaftTruncatedState::clear_has_term() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RaftTruncatedState::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::uint64 RaftTruncatedState::term() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftTruncatedState.term)
  return term_;
}
inline void RaftTruncatedState::set_term(::google::protobuf::uint64 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RaftTruncatedState.term)
}

// -------------------------------------------------------------------

// RaftSnapshotData_KeyValue

// optional bytes key = 1;
inline bool RaftSnapshotData_KeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaftSnapshotData_KeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RaftSnapshotData_KeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RaftSnapshotData_KeyValue::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& RaftSnapshotData_KeyValue::key() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftSnapshotData.KeyValue.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RaftSnapshotData_KeyValue::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.RaftSnapshotData.KeyValue.key)
}
inline void RaftSnapshotData_KeyValue::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.RaftSnapshotData.KeyValue.key)
}
inline void RaftSnapshotData_KeyValue::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.RaftSnapshotData.KeyValue.key)
}
inline ::std::string* RaftSnapshotData_KeyValue::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftSnapshotData.KeyValue.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RaftSnapshotData_KeyValue::release_key() {
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RaftSnapshotData_KeyValue::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftSnapshotData.KeyValue.key)
}

// optional bytes value = 2;
inline bool RaftSnapshotData_KeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RaftSnapshotData_KeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RaftSnapshotData_KeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RaftSnapshotData_KeyValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& RaftSnapshotData_KeyValue::value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftSnapshotData.KeyValue.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RaftSnapshotData_KeyValue::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.RaftSnapshotData.KeyValue.value)
}
inline void RaftSnapshotData_KeyValue::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.RaftSnapshotData.KeyValue.value)
}
inline void RaftSnapshotData_KeyValue::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.RaftSnapshotData.KeyValue.value)
}
inline ::std::string* RaftSnapshotData_KeyValue::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftSnapshotData.KeyValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RaftSnapshotData_KeyValue::release_value() {
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RaftSnapshotData_KeyValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftSnapshotData.KeyValue.value)
}

// -------------------------------------------------------------------

// RaftSnapshotData

// optional .cockroach.proto.RangeDescriptor range_descriptor = 1;
inline bool RaftSnapshotData::has_range_descriptor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaftSnapshotData::set_has_range_descriptor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RaftSnapshotData::clear_has_range_descriptor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RaftSnapshotData::clear_range_descriptor() {
  if (range_descriptor_ != NULL) range_descriptor_->::cockroach::proto::RangeDescriptor::Clear();
  clear_has_range_descriptor();
}
inline const ::cockroach::proto::RangeDescriptor& RaftSnapshotData::range_descriptor() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftSnapshotData.range_descriptor)
  return range_descriptor_ != NULL ? *range_descriptor_ : *default_instance_->range_descriptor_;
}
inline ::cockroach::proto::RangeDescriptor* RaftSnapshotData::mutable_range_descriptor() {
  set_has_range_descriptor();
  if (range_descriptor_ == NULL) {
    range_descriptor_ = new ::cockroach::proto::RangeDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftSnapshotData.range_descriptor)
  return range_descriptor_;
}
inline ::cockroach::proto::RangeDescriptor* RaftSnapshotData::release_range_descriptor() {
  clear_has_range_descriptor();
  ::cockroach::proto::RangeDescriptor* temp = range_descriptor_;
  range_descriptor_ = NULL;
  return temp;
}
inline void RaftSnapshotData::set_allocated_range_descriptor(::cockroach::proto::RangeDescriptor* range_descriptor) {
  delete range_descriptor_;
  range_descriptor_ = range_descriptor;
  if (range_descriptor) {
    set_has_range_descriptor();
  } else {
    clear_has_range_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftSnapshotData.range_descriptor)
}

// repeated .cockroach.proto.RaftSnapshotData.KeyValue KV = 2;
inline int RaftSnapshotData::kv_size() const {
  return kv_.size();
}
inline void RaftSnapshotData::clear_kv() {
  kv_.Clear();
}
inline const ::cockroach::proto::RaftSnapshotData_KeyValue& RaftSnapshotData::kv(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftSnapshotData.KV)
  return kv_.Get(index);
}
inline ::cockroach::proto::RaftSnapshotData_KeyValue* RaftSnapshotData::mutable_kv(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftSnapshotData.KV)
  return kv_.Mutable(index);
}
inline ::cockroach::proto::RaftSnapshotData_KeyValue* RaftSnapshotData::add_kv() {
  // @@protoc_insertion_point(field_add:cockroach.proto.RaftSnapshotData.KV)
  return kv_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RaftSnapshotData_KeyValue >&
RaftSnapshotData::kv() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.RaftSnapshotData.KV)
  return kv_;
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RaftSnapshotData_KeyValue >*
RaftSnapshotData::mutable_kv() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.RaftSnapshotData.KV)
  return &kv_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cockroach

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cockroach::proto::InternalValueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cockroach::proto::InternalValueType>() {
  return ::cockroach::proto::InternalValueType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cockroach_2fproto_2finternal_2eproto__INCLUDED
